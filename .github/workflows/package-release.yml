name: Package Script Release

on:
  release:
    types: [published]
  push:
    tags:
      - 'v*'
    branches:
      - main
  workflow_dispatch:
    inputs:
      tag:
        description: 'Override tag (for manual run diagnostics)'
        required: false
      dryRun:
        description: 'Skip attaching to release'
        required: false
        default: 'false'

permissions:
  contents: write

env:
  WINDOWS_ARCHIVE: TRMM-Windows-Scripts.zip
  LINUX_ARCHIVE: TRMM-Linux-Scripts.zip

jobs:
  build-and-package:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Debug event context
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Tag Input: ${{ inputs.tag }}"
          git tag --list --sort=-creatordate | head -n 15
          echo "Commit message:" && git log -1 --pretty=%B

      - name: Resolve effective tag & previous tag
        id: tags
        env:
          TAG_INPUT: ${{ github.event.inputs.tag }}
        run: |
          CURRENT_TAG="${GITHUB_REF#refs/tags/}"
          if [ -n "$TAG_INPUT" ]; then CURRENT_TAG="$TAG_INPUT"; fi
          echo "Current tag candidate: $CURRENT_TAG"
          ALL_TAGS=$(git tag --sort=-creatordate)
          PREV_TAG=""
          for t in $ALL_TAGS; do
            if [ "$t" = "$CURRENT_TAG" ]; then continue; fi
            PREV_TAG="$t"; break
          done
          echo "Previous tag: $PREV_TAG"
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
          echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT

      - name: Run Windows packaging script (PowerShell Core)
        shell: pwsh
        run: |
          $prev = '${{ steps.tags.outputs.previous_tag }}'
          if ($prev) { ./release/Create-Windows-Release.ps1 -PreviousTag $prev } else { ./release/Create-Windows-Release.ps1 }

      - name: Make Linux script executable
        run: chmod +x release/create-linux-release.sh

      - name: Run Linux packaging script
        run: |
          prev='${{ steps.tags.outputs.previous_tag }}'
          if [ -n "$prev" ]; then ./release/create-linux-release.sh -p "$prev"; else ./release/create-linux-release.sh; fi

      - name: Compute checksums & JSON manifest
        run: |
          cd release
          echo "Generating SHA256SUMS.txt"
          rm -f SHA256SUMS.txt
          for f in TRMM-*Scripts.zip ReleaseNotes-*.md; do
            sha256sum "$f" >> SHA256SUMS.txt
          done
          echo '{"generated":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'","tag":"'${{ steps.tags.outputs.current_tag }}'","previous":"'${{ steps.tags.outputs.previous_tag }}'","archives":[' > manifest.json
          first=1
          for a in TRMM-*Scripts.zip; do
            size=$(stat -c %s "$a")
            if [ $first -eq 0 ]; then echo ',' >> manifest.json; fi
            echo '{"name":"'$a'","size":'$size'}' >> manifest.json
            first=0
          done
          echo '],"notes":[' >> manifest.json
          first=1
          for n in ReleaseNotes-*.md; do
            size=$(stat -c %s "$n")
            if [ $first -eq 0 ]; then echo ',' >> manifest.json; fi
            echo '{"name":"'$n'","size":'$size'}' >> manifest.json
            first=0
          done
          echo ']}' >> manifest.json
          echo "Manifest:" && cat manifest.json

      - name: Upload artifacts (always)
        uses: actions/upload-artifact@v4
        with:
          name: packaged-scripts
          path: |
            release/${{ env.WINDOWS_ARCHIVE }}
            release/ReleaseNotes-Windows.md
            release/${{ env.LINUX_ARCHIVE }}
            release/ReleaseNotes-Linux.md
            release/SHA256SUMS.txt
            release/manifest.json

      - name: Determine next version (auto release on push)
        id: version
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/heads/') && github.ref == 'refs/heads/main'
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -qi '\[skip release\]'; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Release skipped by commit message directive.";
            exit 0
          fi
          TAGS=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*')
          if [ -z "$TAGS" ]; then
            NEW_TAG="v0.1.0"
          else
            LATEST=$(echo "$TAGS" | sort -V | tail -n1)
            MAJOR=$(echo $LATEST | sed -E 's/v([0-9]+)\.[0-9]+\.[0-9]+/\1/')
            MINOR=$(echo $LATEST | sed -E 's/v[0-9]+\.([0-9]+)\.[0-9]+/\1/')
            PATCH=$(echo $LATEST | sed -E 's/v[0-9]+\.[0-9]+\.([0-9]+)/\1/')
            PATCH=$((PATCH+1))
            NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          fi
          echo "Computed next tag: $NEW_TAG"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          git tag "$NEW_TAG"
          git push origin "$NEW_TAG"

      - name: Build changes markdown
        id: changes
        run: |
          PREV='${{ steps.tags.outputs.previous_tag }}'
          CUR='${{ steps.version.outputs.new_tag || steps.tags.outputs.current_tag }}'
          if [ -n "$PREV" ]; then
            TABLE=$(git diff --name-status "$PREV" "$CUR" | awk 'BEGIN{print "| Status | File |"; print "|--------|------|"} {s=$1; f=$2; if(s=="R"){f=$3} emoji=""; if(s=="A")emoji="ğŸ†•"; else if(s=="M")emoji="âœï¸"; else if(s=="D")emoji="ğŸ—‘ï¸"; else if(s=="R")emoji="ğŸ”"; else if(s=="C")emoji="ğŸ“„"; print "| " emoji " " s " | " f " |"}')
            COUNTS=$(git diff --name-status "$PREV" "$CUR" | awk '{c[$1]++} END{for(k in c){emoji=""; if(k=="A")emoji="ğŸ†•"; else if(k=="M")emoji="âœï¸"; else if(k=="D")emoji="ğŸ—‘ï¸"; else if(k=="R")emoji="ğŸ”"; else if(k=="C")emoji="ğŸ“„"; print "- " emoji " " k ":" c[k]}}')
            echo "table<<EOF" >> $GITHUB_OUTPUT
            echo "$TABLE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "counts<<EOF" >> $GITHUB_OUTPUT
            echo "$COUNTS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "initial=false" >> $GITHUB_OUTPUT
          else
            echo "initial=true" >> $GITHUB_OUTPUT
          fi

      - name: Auto create release from push
        if: steps.version.outputs.skip != 'true' && steps.version.outputs.new_tag && github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.new_tag }}
          name: ${{ steps.version.outputs.new_tag }}
          body: |
            ## ğŸš€ TRMM Scripts ${{ steps.version.outputs.new_tag }}
            Prev Tag: `${{ steps.tags.outputs.previous_tag || 'âˆ… initial' }}`
            Commit: `${{ github.sha }}` | Run: `${{ github.run_id }}`

            ### ğŸ”„ Changes
            **Status Legend:** ğŸ†• Added | âœï¸ Modified | ğŸ—‘ï¸ Deleted | ğŸ” Renamed
            ${{ steps.changes.outputs.initial == 'true' && 'Initial release â€“ all current files included.' || '' }}
            ${{ steps.changes.outputs.initial == 'true' && '' || '**Counts:**' }}
            ${{ steps.changes.outputs.initial == 'true' && '' || steps.changes.outputs.counts }}
            ${{ steps.changes.outputs.initial == 'true' && '' || steps.changes.outputs.table }}

            ### ğŸ“¦ Archives
            Windows: ${{ env.WINDOWS_ARCHIVE }} | Linux: ${{ env.LINUX_ARCHIVE }}

            âœ¨ Automation complete.
          files: |
            release/${{ env.WINDOWS_ARCHIVE }}
            release/${{ env.LINUX_ARCHIVE }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Attach assets to release
        if: github.event_name == 'release' && github.event.inputs.dryRun != 'true'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release/${{ env.WINDOWS_ARCHIVE }}
            release/${{ env.LINUX_ARCHIVE }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
